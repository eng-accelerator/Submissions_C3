"""Vulnerability Scanner Agent - Identifies security weaknesses"""
from typing import List, Dict, Any, Optional
from datetime import datetime
import re
from .base_agent import BaseAgent, SecurityAlert, AlertSeverity

# Import CVE RAG Agent for enhanced vulnerability detection
try:
    from .cve_rag_agent import CVERAGAgent
    CVE_RAG_AVAILABLE = True
except ImportError:
    CVE_RAG_AVAILABLE = False

class VulnerabilityScannerAgent(BaseAgent):
    KNOWN_CVES = {
        "CVE-2024-0001": {
            "severity": "critical", 
            "description": "Remote code execution", 
            "affected_software": ["Apache", "apache", "httpd"],
            "affected_versions": ["<2.0.0"]
        },
        "CVE-2024-0002": {
            "severity": "high", 
            "description": "Privilege escalation", 
            "affected_software": ["MySQL", "mysql", "mariadb"],
            "affected_versions": ["<1.5.0"]
        }
    }
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        super().__init__("vulnerability_scanner", "Vulnerability Scanner Agent", config)
        self.scan_results = []
        # Initialize CVE RAG agent if available
        self.cve_rag_agent = None
        if CVE_RAG_AVAILABLE:
            try:
                rag_config = config.get("cve_rag", {}) if config else {}
                self.cve_rag_agent = CVERAGAgent(rag_config)
                # Set coordinator when available
                if hasattr(self, '_coordinator') and self._coordinator:
                    self.cve_rag_agent.set_coordinator(self._coordinator)
            except Exception as e:
                self.logger.warning(f"CVE RAG agent not available: {e}")
    
    def get_capabilities(self) -> Dict[str, Any]:
        capabilities = {
            "scan_types": ["software_versions", "configuration_audit", "secret_detection"],
            "standards": ["CVE", "CVSS"]
        }
        if self.cve_rag_agent:
            capabilities["rag_enabled"] = True
            capabilities["cve_rag_capabilities"] = self.cve_rag_agent.get_capabilities()
        return capabilities
    
    def scan_system(self, system_info: Dict[str, Any]) -> List[SecurityAlert]:
        alerts = []
        if "software" in system_info:
            alerts.extend(self._check_software_versions(system_info["software"]))
        if "configuration" in system_info:
            alerts.extend(self._check_configurations(system_info["configuration"]))
        if "files" in system_info:
            alerts.extend(self._check_exposed_secrets(system_info["files"]))
        for alert in alerts:
            self.send_alert(alert)
        return alerts
    
    def _check_software_versions(self, software: Dict[str, str]) -> List[SecurityAlert]:
        alerts = []
        # First check local CVE database
        for name, version in software.items():
            # Check each CVE to see if this software/version is affected
            for cve_id, cve_info in self.KNOWN_CVES.items():
                # Check if software name matches (case-insensitive)
                affected_software = cve_info.get("affected_software", [])
                software_lower = name.lower()
                
                # Check if this software is affected by this CVE
                if any(sw.lower() == software_lower for sw in affected_software):
                    affected_versions = cve_info.get("affected_versions", [])
                    # Check version constraints
                    for constraint in affected_versions:
                        # Handle version constraints like "<2.0.0", "<1.5.0"
                        if constraint.startswith("<"):
                            try:
                                max_version = constraint[1:].strip()
                                # Simple version comparison (for demo - in production use proper version parsing)
                                if self._version_less_than(version, max_version):
                                    severity = {"critical": AlertSeverity.CRITICAL, "high": AlertSeverity.HIGH}.get(cve_info["severity"], AlertSeverity.MEDIUM)
                                    alert = SecurityAlert(
                                        agent_id=self.agent_id,
                                        alert_type="vulnerable_software",
                                        severity=severity,
                                        description=f"{name} version {version} is vulnerable to {cve_id}: {cve_info.get('description', '')}",
                                        details={"software": name, "version": version, "cve_id": cve_id, "cve_description": cve_info.get("description", "")}
                                    )
                                    alerts.append(alert)
                                    break  # Only report once per CVE
                            except Exception as e:
                                self.logger.warning(f"Error checking version constraint {constraint} for {name} {version}: {e}")
                                pass
            # Also check for common vulnerable software patterns (fallback)
            if software_lower in ["apache", "httpd"] and self._version_less_than(version, "2.4.58"):
                alert = SecurityAlert(
                    agent_id=self.agent_id,
                    alert_type="vulnerable_software",
                    severity=AlertSeverity.HIGH,
                    description=f"{name} version {version} may be vulnerable - consider updating to latest version",
                    details={"software": name, "version": version, "recommendation": "Update to latest version"}
                )
                alerts.append(alert)
            elif software_lower in ["mysql", "mariadb"] and self._version_less_than(version, "8.0.35"):
                alert = SecurityAlert(
                    agent_id=self.agent_id,
                    alert_type="vulnerable_software",
                    severity=AlertSeverity.HIGH,
                    description=f"{name} version {version} may be vulnerable - consider updating to latest version",
                    details={"software": name, "version": version, "recommendation": "Update to latest version"}
                )
                alerts.append(alert)
        
        # Use CVE RAG agent for enhanced search (if available)
        if self.cve_rag_agent:
            for name, version in software.items():
                try:
                    rag_alerts = self.cve_rag_agent.check_software_vulnerability(name, version)
                    alerts.extend(rag_alerts)
                except Exception as e:
                    self.logger.warning(f"RAG search failed for {name}: {e}")
        
        return alerts
    
    def _check_configurations(self, config: Dict[str, Any]) -> List[SecurityAlert]:
        alerts = []
        if config.get("debug_mode") == True:
            alert = SecurityAlert(
                agent_id=self.agent_id,
                alert_type="insecure_configuration",
                severity=AlertSeverity.MEDIUM,
                description="Debug mode is enabled in production",
                details={"configuration": "debug_mode", "value": True}
            )
            alerts.append(alert)
        return alerts
    
    def _check_exposed_secrets(self, files: List[Dict[str, Any]]) -> List[SecurityAlert]:
        alerts = []
        secret_patterns = {
            "api_key": r"(?i)(api[_-]?key|apikey)\s*[=:]\s*['\"]?([a-zA-Z0-9]{20,})['\"]?",
            "password": r"(?i)(password|pwd)\s*[=:]\s*['\"]?([^\s'\"]+)['\"]?"
        }
        for file_info in files:
            content = file_info.get("content", "")
            for secret_type, pattern in secret_patterns.items():
                if re.search(pattern, content):
                    alert = SecurityAlert(
                        agent_id=self.agent_id,
                        alert_type="exposed_secret",
                        severity=AlertSeverity.CRITICAL,
                        description=f"Exposed {secret_type} found in {file_info.get('path', '')}",
                        details={"file_path": file_info.get("path", ""), "secret_type": secret_type}
                    )
                    alerts.append(alert)
                    break
        return alerts
    
    def _version_less_than(self, version1: str, version2: str) -> bool:
        """Simple version comparison - returns True if version1 < version2"""
        try:
            # Split versions by dots and compare numerically
            v1_parts = [int(x) for x in version1.split('.')]
            v2_parts = [int(x) for x in version2.split('.')]
            # Pad with zeros to same length
            max_len = max(len(v1_parts), len(v2_parts))
            v1_parts.extend([0] * (max_len - len(v1_parts)))
            v2_parts.extend([0] * (max_len - len(v2_parts)))
            # Compare
            return v1_parts < v2_parts
        except:
            # If version parsing fails, do string comparison
            return version1 < version2
    
    def analyze(self, data: Any) -> List[SecurityAlert]:
        if isinstance(data, dict):
            return self.scan_system(data)
        return []

